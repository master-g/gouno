// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: game.proto

package pb // import "github.com/master-g/gouno/api/pb"

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Command Codes
// S -> C : even
// C -> S : odd
type GameCmd int32

const (
	GameCmd_GAME_RESERVED   GameCmd = 0
	GameCmd_ENTER_GAME_REQ  GameCmd = 8193
	GameCmd_ENTER_GAME_RESP GameCmd = 8194
	GameCmd_ACTION_REQ      GameCmd = 8195
	GameCmd_ACTION_RESP     GameCmd = 8196
	GameCmd_EVENT_NTY       GameCmd = 8198
	GameCmd_PLAYER_JOIN_NTY GameCmd = 8200
	GameCmd_PLAYER_LEFT_NTY GameCmd = 8202
	GameCmd_GAME_START_NTY  GameCmd = 8204
	GameCmd_GAME_OVER_NTY   GameCmd = 8206
)

var GameCmd_name = map[int32]string{
	0:    "GAME_RESERVED",
	8193: "ENTER_GAME_REQ",
	8194: "ENTER_GAME_RESP",
	8195: "ACTION_REQ",
	8196: "ACTION_RESP",
	8198: "EVENT_NTY",
	8200: "PLAYER_JOIN_NTY",
	8202: "PLAYER_LEFT_NTY",
	8204: "GAME_START_NTY",
	8206: "GAME_OVER_NTY",
}
var GameCmd_value = map[string]int32{
	"GAME_RESERVED":   0,
	"ENTER_GAME_REQ":  8193,
	"ENTER_GAME_RESP": 8194,
	"ACTION_REQ":      8195,
	"ACTION_RESP":     8196,
	"EVENT_NTY":       8198,
	"PLAYER_JOIN_NTY": 8200,
	"PLAYER_LEFT_NTY": 8202,
	"GAME_START_NTY":  8204,
	"GAME_OVER_NTY":   8206,
}

func (x GameCmd) String() string {
	return proto.EnumName(GameCmd_name, int32(x))
}
func (GameCmd) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_game_34204da01c2dcc5d, []int{0}
}

type Event int32

const (
	Event_EVENT_RESERVED          Event = 0
	Event_EVENT_TURN              Event = 1
	Event_EVENT_PLAY              Event = 2
	Event_EVENT_UNO_PLAY          Event = 3
	Event_EVENT_DRAW              Event = 4
	Event_EVENT_SKIP              Event = 5
	Event_EVENT_CHALLENGE         Event = 6
	Event_EVENT_CHALLENGE_PENALTY Event = 7
	Event_EVENT_TIMEOUT           Event = 8
	Event_EVENT_DECK_SHUFFLE      Event = 9
)

var Event_name = map[int32]string{
	0: "EVENT_RESERVED",
	1: "EVENT_TURN",
	2: "EVENT_PLAY",
	3: "EVENT_UNO_PLAY",
	4: "EVENT_DRAW",
	5: "EVENT_SKIP",
	6: "EVENT_CHALLENGE",
	7: "EVENT_CHALLENGE_PENALTY",
	8: "EVENT_TIMEOUT",
	9: "EVENT_DECK_SHUFFLE",
}
var Event_value = map[string]int32{
	"EVENT_RESERVED":          0,
	"EVENT_TURN":              1,
	"EVENT_PLAY":              2,
	"EVENT_UNO_PLAY":          3,
	"EVENT_DRAW":              4,
	"EVENT_SKIP":              5,
	"EVENT_CHALLENGE":         6,
	"EVENT_CHALLENGE_PENALTY": 7,
	"EVENT_TIMEOUT":           8,
	"EVENT_DECK_SHUFFLE":      9,
}

func (x Event) String() string {
	return proto.EnumName(Event_name, int32(x))
}
func (Event) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_game_34204da01c2dcc5d, []int{1}
}

type Action int32

const (
	Action_ACTION_RESERVED  Action = 0
	Action_ACTION_PLAY      Action = 1
	Action_ACTION_UNO_PLAY  Action = 2
	Action_ACTION_DRAW      Action = 3
	Action_ACTION_CHALLENGE Action = 4
)

var Action_name = map[int32]string{
	0: "ACTION_RESERVED",
	1: "ACTION_PLAY",
	2: "ACTION_UNO_PLAY",
	3: "ACTION_DRAW",
	4: "ACTION_CHALLENGE",
}
var Action_value = map[string]int32{
	"ACTION_RESERVED":  0,
	"ACTION_PLAY":      1,
	"ACTION_UNO_PLAY":  2,
	"ACTION_DRAW":      3,
	"ACTION_CHALLENGE": 4,
}

func (x Action) String() string {
	return proto.EnumName(Action_name, int32(x))
}
func (Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_game_34204da01c2dcc5d, []int{2}
}

type CardColor int32

const (
	CardColor_COLOR_RED    CardColor = 0
	CardColor_COLOR_YELLOW CardColor = 16
	CardColor_COLOR_BLUE   CardColor = 32
	CardColor_COLOR_GREEN  CardColor = 48
)

var CardColor_name = map[int32]string{
	0:  "COLOR_RED",
	16: "COLOR_YELLOW",
	32: "COLOR_BLUE",
	48: "COLOR_GREEN",
}
var CardColor_value = map[string]int32{
	"COLOR_RED":    0,
	"COLOR_YELLOW": 16,
	"COLOR_BLUE":   32,
	"COLOR_GREEN":  48,
}

func (x CardColor) String() string {
	return proto.EnumName(CardColor_name, int32(x))
}
func (CardColor) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_game_34204da01c2dcc5d, []int{3}
}

type PlayerStatus int32

const (
	PlayerStatus_STATUS_DEFAULT   PlayerStatus = 0
	PlayerStatus_STATUS_UNO       PlayerStatus = 1
	PlayerStatus_STATUS_SKIP      PlayerStatus = 2
	PlayerStatus_STATUS_DRAW      PlayerStatus = 4
	PlayerStatus_STATUS_CHALLENGE PlayerStatus = 8
)

var PlayerStatus_name = map[int32]string{
	0: "STATUS_DEFAULT",
	1: "STATUS_UNO",
	2: "STATUS_SKIP",
	4: "STATUS_DRAW",
	8: "STATUS_CHALLENGE",
}
var PlayerStatus_value = map[string]int32{
	"STATUS_DEFAULT":   0,
	"STATUS_UNO":       1,
	"STATUS_SKIP":      2,
	"STATUS_DRAW":      4,
	"STATUS_CHALLENGE": 8,
}

func (x PlayerStatus) String() string {
	return proto.EnumName(PlayerStatus_name, int32(x))
}
func (PlayerStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_game_34204da01c2dcc5d, []int{4}
}

type TableStatus int32

const (
	TableStatus_STATUS_IDLE      TableStatus = 0
	TableStatus_STATUS_WAIT      TableStatus = 1
	TableStatus_STATUS_PLAYING   TableStatus = 2
	TableStatus_STATUS_GAME_OVER TableStatus = 3
)

var TableStatus_name = map[int32]string{
	0: "STATUS_IDLE",
	1: "STATUS_WAIT",
	2: "STATUS_PLAYING",
	3: "STATUS_GAME_OVER",
}
var TableStatus_value = map[string]int32{
	"STATUS_IDLE":      0,
	"STATUS_WAIT":      1,
	"STATUS_PLAYING":   2,
	"STATUS_GAME_OVER": 3,
}

func (x TableStatus) String() string {
	return proto.EnumName(TableStatus_name, int32(x))
}
func (TableStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_game_34204da01c2dcc5d, []int{5}
}

type UnoPlayer struct {
	Uid                  uint64   `protobuf:"fixed64,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Status               int32    `protobuf:"varint,3,opt,name=status,proto3" json:"status,omitempty"`
	Cards                []byte   `protobuf:"bytes,4,opt,name=cards,proto3" json:"cards,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnoPlayer) Reset()         { *m = UnoPlayer{} }
func (m *UnoPlayer) String() string { return proto.CompactTextString(m) }
func (*UnoPlayer) ProtoMessage()    {}
func (*UnoPlayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_34204da01c2dcc5d, []int{0}
}
func (m *UnoPlayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnoPlayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnoPlayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UnoPlayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnoPlayer.Merge(dst, src)
}
func (m *UnoPlayer) XXX_Size() int {
	return m.Size()
}
func (m *UnoPlayer) XXX_DiscardUnknown() {
	xxx_messageInfo_UnoPlayer.DiscardUnknown(m)
}

var xxx_messageInfo_UnoPlayer proto.InternalMessageInfo

func (m *UnoPlayer) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UnoPlayer) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *UnoPlayer) GetCards() []byte {
	if m != nil {
		return m.Cards
	}
	return nil
}

type TableState struct {
	Tid                  uint64       `protobuf:"fixed64,1,opt,name=tid,proto3" json:"tid,omitempty"`
	Status               TableStatus  `protobuf:"varint,2,opt,name=status,proto3,enum=proto.game.TableStatus" json:"status,omitempty"`
	Timeout              int32        `protobuf:"varint,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
	TimeLeft             int32        `protobuf:"varint,4,opt,name=time_left,json=timeLeft,proto3" json:"time_left,omitempty"`
	Clockwise            bool         `protobuf:"varint,5,opt,name=clockwise,proto3" json:"clockwise,omitempty"`
	LastPlayer           uint64       `protobuf:"fixed64,7,opt,name=last_player,json=lastPlayer,proto3" json:"last_player,omitempty"`
	CurrentPlayer        uint64       `protobuf:"fixed64,8,opt,name=current_player,json=currentPlayer,proto3" json:"current_player,omitempty"`
	CardsLeft            int32        `protobuf:"varint,9,opt,name=cards_left,json=cardsLeft,proto3" json:"cards_left,omitempty"`
	DiscardPile          []byte       `protobuf:"bytes,10,opt,name=discard_pile,json=discardPile,proto3" json:"discard_pile,omitempty"`
	Players              []*UnoPlayer `protobuf:"bytes,11,rep,name=players" json:"players,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *TableState) Reset()         { *m = TableState{} }
func (m *TableState) String() string { return proto.CompactTextString(m) }
func (*TableState) ProtoMessage()    {}
func (*TableState) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_34204da01c2dcc5d, []int{1}
}
func (m *TableState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TableState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableState.Merge(dst, src)
}
func (m *TableState) XXX_Size() int {
	return m.Size()
}
func (m *TableState) XXX_DiscardUnknown() {
	xxx_messageInfo_TableState.DiscardUnknown(m)
}

var xxx_messageInfo_TableState proto.InternalMessageInfo

func (m *TableState) GetTid() uint64 {
	if m != nil {
		return m.Tid
	}
	return 0
}

func (m *TableState) GetStatus() TableStatus {
	if m != nil {
		return m.Status
	}
	return TableStatus_STATUS_IDLE
}

func (m *TableState) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *TableState) GetTimeLeft() int32 {
	if m != nil {
		return m.TimeLeft
	}
	return 0
}

func (m *TableState) GetClockwise() bool {
	if m != nil {
		return m.Clockwise
	}
	return false
}

func (m *TableState) GetLastPlayer() uint64 {
	if m != nil {
		return m.LastPlayer
	}
	return 0
}

func (m *TableState) GetCurrentPlayer() uint64 {
	if m != nil {
		return m.CurrentPlayer
	}
	return 0
}

func (m *TableState) GetCardsLeft() int32 {
	if m != nil {
		return m.CardsLeft
	}
	return 0
}

func (m *TableState) GetDiscardPile() []byte {
	if m != nil {
		return m.DiscardPile
	}
	return nil
}

func (m *TableState) GetPlayers() []*UnoPlayer {
	if m != nil {
		return m.Players
	}
	return nil
}

type S2CPlayerJoinNty struct {
	Uid                  uint64   `protobuf:"fixed64,1,opt,name=uid,proto3" json:"uid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CPlayerJoinNty) Reset()         { *m = S2CPlayerJoinNty{} }
func (m *S2CPlayerJoinNty) String() string { return proto.CompactTextString(m) }
func (*S2CPlayerJoinNty) ProtoMessage()    {}
func (*S2CPlayerJoinNty) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_34204da01c2dcc5d, []int{2}
}
func (m *S2CPlayerJoinNty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CPlayerJoinNty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CPlayerJoinNty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2CPlayerJoinNty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CPlayerJoinNty.Merge(dst, src)
}
func (m *S2CPlayerJoinNty) XXX_Size() int {
	return m.Size()
}
func (m *S2CPlayerJoinNty) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CPlayerJoinNty.DiscardUnknown(m)
}

var xxx_messageInfo_S2CPlayerJoinNty proto.InternalMessageInfo

func (m *S2CPlayerJoinNty) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type S2CPlayerLeftNty struct {
	Uid                  uint64   `protobuf:"fixed64,1,opt,name=uid,proto3" json:"uid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CPlayerLeftNty) Reset()         { *m = S2CPlayerLeftNty{} }
func (m *S2CPlayerLeftNty) String() string { return proto.CompactTextString(m) }
func (*S2CPlayerLeftNty) ProtoMessage()    {}
func (*S2CPlayerLeftNty) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_34204da01c2dcc5d, []int{3}
}
func (m *S2CPlayerLeftNty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CPlayerLeftNty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CPlayerLeftNty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2CPlayerLeftNty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CPlayerLeftNty.Merge(dst, src)
}
func (m *S2CPlayerLeftNty) XXX_Size() int {
	return m.Size()
}
func (m *S2CPlayerLeftNty) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CPlayerLeftNty.DiscardUnknown(m)
}

var xxx_messageInfo_S2CPlayerLeftNty proto.InternalMessageInfo

func (m *S2CPlayerLeftNty) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type C2SActionReq struct {
	Action               int32    `protobuf:"varint,1,opt,name=action,proto3" json:"action,omitempty"`
	Card                 []byte   `protobuf:"bytes,2,opt,name=card,proto3" json:"card,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2SActionReq) Reset()         { *m = C2SActionReq{} }
func (m *C2SActionReq) String() string { return proto.CompactTextString(m) }
func (*C2SActionReq) ProtoMessage()    {}
func (*C2SActionReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_34204da01c2dcc5d, []int{4}
}
func (m *C2SActionReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SActionReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SActionReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *C2SActionReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SActionReq.Merge(dst, src)
}
func (m *C2SActionReq) XXX_Size() int {
	return m.Size()
}
func (m *C2SActionReq) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SActionReq.DiscardUnknown(m)
}

var xxx_messageInfo_C2SActionReq proto.InternalMessageInfo

func (m *C2SActionReq) GetAction() int32 {
	if m != nil {
		return m.Action
	}
	return 0
}

func (m *C2SActionReq) GetCard() []byte {
	if m != nil {
		return m.Card
	}
	return nil
}

type S2CActionResp struct {
	Result               int32    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Card                 []byte   `protobuf:"bytes,2,opt,name=card,proto3" json:"card,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CActionResp) Reset()         { *m = S2CActionResp{} }
func (m *S2CActionResp) String() string { return proto.CompactTextString(m) }
func (*S2CActionResp) ProtoMessage()    {}
func (*S2CActionResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_34204da01c2dcc5d, []int{5}
}
func (m *S2CActionResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CActionResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CActionResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2CActionResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CActionResp.Merge(dst, src)
}
func (m *S2CActionResp) XXX_Size() int {
	return m.Size()
}
func (m *S2CActionResp) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CActionResp.DiscardUnknown(m)
}

var xxx_messageInfo_S2CActionResp proto.InternalMessageInfo

func (m *S2CActionResp) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *S2CActionResp) GetCard() []byte {
	if m != nil {
		return m.Card
	}
	return nil
}

type SingleEvent struct {
	Uid                  uint64   `protobuf:"fixed64,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Event                int32    `protobuf:"varint,2,opt,name=event,proto3" json:"event,omitempty"`
	Card                 []byte   `protobuf:"bytes,3,opt,name=card,proto3" json:"card,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SingleEvent) Reset()         { *m = SingleEvent{} }
func (m *SingleEvent) String() string { return proto.CompactTextString(m) }
func (*SingleEvent) ProtoMessage()    {}
func (*SingleEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_34204da01c2dcc5d, []int{6}
}
func (m *SingleEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SingleEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SingleEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SingleEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SingleEvent.Merge(dst, src)
}
func (m *SingleEvent) XXX_Size() int {
	return m.Size()
}
func (m *SingleEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_SingleEvent.DiscardUnknown(m)
}

var xxx_messageInfo_SingleEvent proto.InternalMessageInfo

func (m *SingleEvent) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *SingleEvent) GetEvent() int32 {
	if m != nil {
		return m.Event
	}
	return 0
}

func (m *SingleEvent) GetCard() []byte {
	if m != nil {
		return m.Card
	}
	return nil
}

type S2CEventNty struct {
	Events               []*SingleEvent `protobuf:"bytes,1,rep,name=events" json:"events,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *S2CEventNty) Reset()         { *m = S2CEventNty{} }
func (m *S2CEventNty) String() string { return proto.CompactTextString(m) }
func (*S2CEventNty) ProtoMessage()    {}
func (*S2CEventNty) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_34204da01c2dcc5d, []int{7}
}
func (m *S2CEventNty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CEventNty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CEventNty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2CEventNty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CEventNty.Merge(dst, src)
}
func (m *S2CEventNty) XXX_Size() int {
	return m.Size()
}
func (m *S2CEventNty) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CEventNty.DiscardUnknown(m)
}

var xxx_messageInfo_S2CEventNty proto.InternalMessageInfo

func (m *S2CEventNty) GetEvents() []*SingleEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

type S2CGameOverNty struct {
	Ranks                []uint64 `protobuf:"fixed64,1,rep,packed,name=ranks" json:"ranks,omitempty"`
	Scores               []int32  `protobuf:"varint,2,rep,packed,name=scores" json:"scores,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CGameOverNty) Reset()         { *m = S2CGameOverNty{} }
func (m *S2CGameOverNty) String() string { return proto.CompactTextString(m) }
func (*S2CGameOverNty) ProtoMessage()    {}
func (*S2CGameOverNty) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_34204da01c2dcc5d, []int{8}
}
func (m *S2CGameOverNty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CGameOverNty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CGameOverNty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2CGameOverNty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CGameOverNty.Merge(dst, src)
}
func (m *S2CGameOverNty) XXX_Size() int {
	return m.Size()
}
func (m *S2CGameOverNty) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CGameOverNty.DiscardUnknown(m)
}

var xxx_messageInfo_S2CGameOverNty proto.InternalMessageInfo

func (m *S2CGameOverNty) GetRanks() []uint64 {
	if m != nil {
		return m.Ranks
	}
	return nil
}

func (m *S2CGameOverNty) GetScores() []int32 {
	if m != nil {
		return m.Scores
	}
	return nil
}

func init() {
	proto.RegisterType((*UnoPlayer)(nil), "proto.game.UnoPlayer")
	proto.RegisterType((*TableState)(nil), "proto.game.TableState")
	proto.RegisterType((*S2CPlayerJoinNty)(nil), "proto.game.S2CPlayerJoinNty")
	proto.RegisterType((*S2CPlayerLeftNty)(nil), "proto.game.S2CPlayerLeftNty")
	proto.RegisterType((*C2SActionReq)(nil), "proto.game.C2SActionReq")
	proto.RegisterType((*S2CActionResp)(nil), "proto.game.S2CActionResp")
	proto.RegisterType((*SingleEvent)(nil), "proto.game.SingleEvent")
	proto.RegisterType((*S2CEventNty)(nil), "proto.game.S2CEventNty")
	proto.RegisterType((*S2CGameOverNty)(nil), "proto.game.S2CGameOverNty")
	proto.RegisterEnum("proto.game.GameCmd", GameCmd_name, GameCmd_value)
	proto.RegisterEnum("proto.game.Event", Event_name, Event_value)
	proto.RegisterEnum("proto.game.Action", Action_name, Action_value)
	proto.RegisterEnum("proto.game.CardColor", CardColor_name, CardColor_value)
	proto.RegisterEnum("proto.game.PlayerStatus", PlayerStatus_name, PlayerStatus_value)
	proto.RegisterEnum("proto.game.TableStatus", TableStatus_name, TableStatus_value)
}
func (m *UnoPlayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnoPlayer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Uid))
		i += 8
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Status))
	}
	if len(m.Cards) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Cards)))
		i += copy(dAtA[i:], m.Cards)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TableState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tid != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Tid))
		i += 8
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Status))
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Timeout))
	}
	if m.TimeLeft != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.TimeLeft))
	}
	if m.Clockwise {
		dAtA[i] = 0x28
		i++
		if m.Clockwise {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LastPlayer != 0 {
		dAtA[i] = 0x39
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.LastPlayer))
		i += 8
	}
	if m.CurrentPlayer != 0 {
		dAtA[i] = 0x41
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.CurrentPlayer))
		i += 8
	}
	if m.CardsLeft != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.CardsLeft))
	}
	if len(m.DiscardPile) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.DiscardPile)))
		i += copy(dAtA[i:], m.DiscardPile)
	}
	if len(m.Players) > 0 {
		for _, msg := range m.Players {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *S2CPlayerJoinNty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CPlayerJoinNty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Uid))
		i += 8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *S2CPlayerLeftNty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CPlayerLeftNty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Uid))
		i += 8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *C2SActionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SActionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Action))
	}
	if len(m.Card) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Card)))
		i += copy(dAtA[i:], m.Card)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *S2CActionResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CActionResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Result))
	}
	if len(m.Card) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Card)))
		i += copy(dAtA[i:], m.Card)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SingleEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SingleEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Uid))
		i += 8
	}
	if m.Event != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Event))
	}
	if len(m.Card) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Card)))
		i += copy(dAtA[i:], m.Card)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *S2CEventNty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CEventNty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *S2CGameOverNty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CGameOverNty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ranks) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Ranks)*8))
		for _, num := range m.Ranks {
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(num))
			i += 8
		}
	}
	if len(m.Scores) > 0 {
		dAtA2 := make([]byte, len(m.Scores)*10)
		var j1 int
		for _, num1 := range m.Scores {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintGame(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *UnoPlayer) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 9
	}
	if m.Status != 0 {
		n += 1 + sovGame(uint64(m.Status))
	}
	l = len(m.Cards)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableState) Size() (n int) {
	var l int
	_ = l
	if m.Tid != 0 {
		n += 9
	}
	if m.Status != 0 {
		n += 1 + sovGame(uint64(m.Status))
	}
	if m.Timeout != 0 {
		n += 1 + sovGame(uint64(m.Timeout))
	}
	if m.TimeLeft != 0 {
		n += 1 + sovGame(uint64(m.TimeLeft))
	}
	if m.Clockwise {
		n += 2
	}
	if m.LastPlayer != 0 {
		n += 9
	}
	if m.CurrentPlayer != 0 {
		n += 9
	}
	if m.CardsLeft != 0 {
		n += 1 + sovGame(uint64(m.CardsLeft))
	}
	l = len(m.DiscardPile)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CPlayerJoinNty) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CPlayerLeftNty) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *C2SActionReq) Size() (n int) {
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovGame(uint64(m.Action))
	}
	l = len(m.Card)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CActionResp) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovGame(uint64(m.Result))
	}
	l = len(m.Card)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SingleEvent) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 9
	}
	if m.Event != 0 {
		n += 1 + sovGame(uint64(m.Event))
	}
	l = len(m.Card)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CEventNty) Size() (n int) {
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CGameOverNty) Size() (n int) {
	var l int
	_ = l
	if len(m.Ranks) > 0 {
		n += 1 + sovGame(uint64(len(m.Ranks)*8)) + len(m.Ranks)*8
	}
	if len(m.Scores) > 0 {
		l = 0
		for _, e := range m.Scores {
			l += sovGame(uint64(e))
		}
		n += 1 + sovGame(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovGame(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGame(x uint64) (n int) {
	return sovGame(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UnoPlayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnoPlayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnoPlayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards[:0], dAtA[iNdEx:postIndex]...)
			if m.Cards == nil {
				m.Cards = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			m.Tid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Tid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (TableStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeLeft", wireType)
			}
			m.TimeLeft = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeLeft |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clockwise", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Clockwise = bool(v != 0)
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastPlayer", wireType)
			}
			m.LastPlayer = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.LastPlayer = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentPlayer", wireType)
			}
			m.CurrentPlayer = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentPlayer = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardsLeft", wireType)
			}
			m.CardsLeft = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardsLeft |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscardPile", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiscardPile = append(m.DiscardPile[:0], dAtA[iNdEx:postIndex]...)
			if m.DiscardPile == nil {
				m.DiscardPile = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &UnoPlayer{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CPlayerJoinNty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CPlayerJoinNty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CPlayerJoinNty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CPlayerLeftNty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CPlayerLeftNty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CPlayerLeftNty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SActionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SActionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SActionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Card = append(m.Card[:0], dAtA[iNdEx:postIndex]...)
			if m.Card == nil {
				m.Card = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CActionResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CActionResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CActionResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Card = append(m.Card[:0], dAtA[iNdEx:postIndex]...)
			if m.Card == nil {
				m.Card = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingleEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			m.Event = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Event |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Card = append(m.Card[:0], dAtA[iNdEx:postIndex]...)
			if m.Card == nil {
				m.Card = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CEventNty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CEventNty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CEventNty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &SingleEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CGameOverNty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CGameOverNty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CGameOverNty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.Ranks = append(m.Ranks, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGame
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if len(m.Ranks) == 0 {
					m.Ranks = make([]uint64, 0, packedLen/8)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.Ranks = append(m.Ranks, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranks", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Scores = append(m.Scores, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGame
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGame
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Scores = append(m.Scores, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Scores", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGame(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGame
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGame
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGame
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGame
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGame
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGame(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGame = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGame   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("game.proto", fileDescriptor_game_34204da01c2dcc5d) }

var fileDescriptor_game_34204da01c2dcc5d = []byte{
	// 915 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x54, 0x5d, 0x6f, 0xe3, 0x44,
	0x14, 0xc5, 0x49, 0x9d, 0x36, 0x37, 0x69, 0x3a, 0xcc, 0x86, 0xdd, 0x48, 0x0b, 0x25, 0x44, 0x20,
	0x45, 0x91, 0x48, 0x50, 0x78, 0x03, 0x69, 0x15, 0xaf, 0x3b, 0xcd, 0x66, 0xeb, 0xda, 0x61, 0xec,
	0xb4, 0x0a, 0x2f, 0x96, 0x9b, 0xcc, 0x06, 0xef, 0x3a, 0x71, 0xb0, 0x9d, 0x45, 0xfb, 0xc8, 0x87,
	0x10, 0x42, 0x88, 0xdf, 0xc5, 0x03, 0x12, 0xfc, 0x03, 0x50, 0x7f, 0x09, 0x9a, 0x19, 0xc7, 0x76,
	0xd9, 0x3e, 0xc5, 0xe7, 0xe4, 0xdc, 0x7b, 0xcf, 0x3d, 0x33, 0x36, 0xc0, 0xca, 0x5b, 0xb3, 0xfe,
	0x36, 0x0a, 0x93, 0x10, 0x83, 0xf8, 0xe9, 0x73, 0xa6, 0x73, 0x01, 0xd5, 0xd9, 0x26, 0x9c, 0x06,
	0xde, 0x1b, 0x16, 0x61, 0x04, 0xe5, 0x9d, 0xbf, 0x6c, 0x29, 0x6d, 0xa5, 0x5b, 0xa1, 0xfc, 0x11,
	0x3f, 0x84, 0x4a, 0x9c, 0x78, 0xc9, 0x2e, 0x6e, 0x95, 0xdb, 0x4a, 0x57, 0xa5, 0x29, 0xc2, 0x4d,
	0x50, 0x17, 0x5e, 0xb4, 0x8c, 0x5b, 0x07, 0x6d, 0xa5, 0x5b, 0xa7, 0x12, 0x74, 0xfe, 0x29, 0x01,
	0x38, 0xde, 0x4d, 0xc0, 0xec, 0xc4, 0x4b, 0x18, 0x6f, 0x97, 0xe4, 0xed, 0x12, 0x7f, 0x89, 0x07,
	0x59, 0xbb, 0x52, 0x5b, 0xe9, 0x36, 0x86, 0x8f, 0xfa, 0xb9, 0x95, 0x7e, 0x56, 0xb9, 0x8b, 0xb3,
	0x39, 0x2d, 0x38, 0x4c, 0xfc, 0x35, 0x0b, 0x77, 0x49, 0x6a, 0x60, 0x0f, 0xf1, 0x63, 0xa8, 0xf2,
	0x47, 0x37, 0x60, 0x2f, 0x12, 0xe1, 0x42, 0xa5, 0x47, 0x9c, 0x30, 0xd8, 0x8b, 0x04, 0xbf, 0x0f,
	0xd5, 0x45, 0x10, 0x2e, 0x5e, 0x7d, 0xe7, 0xc7, 0xac, 0xa5, 0xb6, 0x95, 0xee, 0x11, 0xcd, 0x09,
	0xfc, 0x21, 0xd4, 0x02, 0x2f, 0x4e, 0xdc, 0xad, 0xd8, 0xba, 0x75, 0x28, 0xfc, 0x01, 0xa7, 0xd2,
	0x1c, 0x3e, 0x81, 0xc6, 0x62, 0x17, 0x45, 0x6c, 0x93, 0x69, 0x8e, 0x84, 0xe6, 0x38, 0x65, 0x53,
	0xd9, 0x07, 0x00, 0x62, 0x6f, 0xe9, 0xa1, 0x2a, 0x3c, 0x54, 0x05, 0x23, 0x4c, 0x7c, 0x04, 0xf5,
	0xa5, 0x1f, 0x73, 0xec, 0x6e, 0xfd, 0x80, 0xb5, 0x40, 0x44, 0x55, 0x4b, 0xb9, 0xa9, 0x1f, 0x30,
	0x3c, 0x80, 0x43, 0x39, 0x20, 0x6e, 0xd5, 0xda, 0xe5, 0x6e, 0x6d, 0xf8, 0x5e, 0x31, 0x90, 0xec,
	0x60, 0xe8, 0x5e, 0xd5, 0xf9, 0x18, 0x90, 0x3d, 0xd4, 0x25, 0xfb, 0x3c, 0xf4, 0x37, 0x66, 0xf2,
	0xe6, 0xed, 0x53, 0xbb, 0xa3, 0xe2, 0x56, 0xee, 0x57, 0x7d, 0x01, 0x75, 0x7d, 0x68, 0x6b, 0x8b,
	0xc4, 0x0f, 0x37, 0x94, 0x7d, 0xcb, 0xcf, 0xda, 0x13, 0x40, 0x88, 0x54, 0x9a, 0x22, 0x8c, 0xe1,
	0x80, 0x1b, 0x16, 0x47, 0x56, 0xa7, 0xe2, 0xb9, 0xf3, 0x25, 0x1c, 0xdb, 0x43, 0x7d, 0x5f, 0x1b,
	0x6f, 0x79, 0x71, 0xc4, 0xe2, 0x5d, 0x90, 0xec, 0x8b, 0x25, 0xba, 0xb7, 0x78, 0x02, 0x35, 0xdb,
	0xdf, 0xac, 0x02, 0x46, 0x5e, 0xb3, 0x4d, 0x72, 0xcf, 0xad, 0x6b, 0x82, 0xca, 0xf8, 0x5f, 0xa2,
	0x4a, 0xa5, 0x12, 0x64, 0xad, 0xca, 0x85, 0x56, 0x4f, 0xa0, 0x66, 0x0f, 0x75, 0xd1, 0x87, 0x2f,
	0x39, 0x80, 0x8a, 0xd0, 0xc6, 0x2d, 0x45, 0xc4, 0x79, 0xe7, 0x7e, 0x15, 0x66, 0xd2, 0x54, 0xd6,
	0x79, 0x02, 0x0d, 0x7b, 0xa8, 0x8f, 0xbd, 0x35, 0xb3, 0x5e, 0xb3, 0x88, 0xb7, 0x68, 0x82, 0x1a,
	0x79, 0x9b, 0x57, 0xb2, 0x43, 0x85, 0x4a, 0x20, 0xde, 0x83, 0x45, 0x18, 0x31, 0x7e, 0x71, 0xcb,
	0xe2, 0x3d, 0x10, 0xa8, 0xf7, 0x97, 0x02, 0x87, 0xbc, 0x5a, 0x5f, 0x2f, 0xf1, 0xbb, 0x70, 0x3c,
	0xd6, 0x2e, 0x89, 0x4b, 0x89, 0x4d, 0xe8, 0x15, 0x39, 0x43, 0xef, 0xe0, 0x07, 0xd0, 0x20, 0xa6,
	0x43, 0xa8, 0x9b, 0xfe, 0xf1, 0x15, 0xfa, 0x7e, 0x84, 0x9b, 0x70, 0x72, 0x87, 0xb4, 0xa7, 0xe8,
	0x87, 0x11, 0x3e, 0x01, 0xd0, 0x74, 0x67, 0x62, 0x99, 0x42, 0xf6, 0xe3, 0x08, 0x23, 0xa8, 0x65,
	0x84, 0x3d, 0x45, 0x3f, 0x8d, 0x70, 0x03, 0xaa, 0xe4, 0x8a, 0x98, 0x8e, 0x6b, 0x3a, 0x73, 0xf4,
	0xb3, 0x68, 0x34, 0x35, 0xb4, 0x39, 0xa1, 0xee, 0x73, 0x6b, 0x62, 0x0a, 0xf6, 0x97, 0x22, 0x6b,
	0x90, 0x73, 0xa9, 0xfd, 0x75, 0xc4, 0x9d, 0x88, 0x71, 0xb6, 0xa3, 0x51, 0x49, 0xfe, 0x36, 0xc2,
	0x38, 0x75, 0x6c, 0x5d, 0x11, 0x2a, 0xb8, 0xdf, 0x47, 0xbd, 0x3f, 0x15, 0x50, 0x49, 0x9a, 0x77,
	0x43, 0x8e, 0x2b, 0x2c, 0xd4, 0x00, 0x90, 0x9c, 0x33, 0xa3, 0x26, 0x52, 0x72, 0xcc, 0x47, 0xa2,
	0x52, 0x5e, 0x33, 0x33, 0x2d, 0xc9, 0x95, 0x73, 0xcd, 0x19, 0xd5, 0xae, 0xd1, 0x41, 0x8e, 0xed,
	0x8b, 0xc9, 0x14, 0xa9, 0xf8, 0x01, 0x9c, 0x48, 0xac, 0x3f, 0xd3, 0x0c, 0x83, 0x98, 0x63, 0x82,
	0x2a, 0xf8, 0x31, 0x3c, 0xfa, 0x1f, 0xe9, 0x4e, 0x89, 0xa9, 0x19, 0xce, 0x1c, 0x1d, 0xf2, 0xa4,
	0x53, 0x17, 0x93, 0x4b, 0x62, 0xcd, 0x1c, 0x74, 0x84, 0x1f, 0x02, 0x4e, 0x87, 0x10, 0xfd, 0xc2,
	0xb5, 0x9f, 0xcd, 0xce, 0xcf, 0x0d, 0x82, 0xaa, 0xbd, 0x97, 0x50, 0x91, 0xb7, 0x94, 0x8f, 0xc9,
	0xf3, 0xdc, 0xef, 0x73, 0x92, 0x85, 0x2c, 0xcc, 0x2a, 0x05, 0x55, 0xb6, 0x41, 0xa9, 0xa0, 0x12,
	0x2b, 0x94, 0x71, 0x13, 0x50, 0x4a, 0xe4, 0x9e, 0x0f, 0x7a, 0x97, 0x50, 0xd5, 0xbd, 0x68, 0xa9,
	0x87, 0x41, 0x18, 0xe1, 0x63, 0xa8, 0xea, 0x96, 0x61, 0x51, 0x97, 0x8a, 0x41, 0x08, 0xea, 0x12,
	0xce, 0x89, 0x61, 0x58, 0xd7, 0x08, 0xf1, 0x18, 0x24, 0xf3, 0xd4, 0x98, 0x11, 0xd4, 0xe6, 0x43,
	0x24, 0x1e, 0x53, 0x42, 0x4c, 0xf4, 0x59, 0xef, 0x25, 0xd4, 0xe5, 0x2b, 0x2c, 0xbf, 0x89, 0x3c,
	0x5b, 0xdb, 0xd1, 0x9c, 0x99, 0xed, 0x9e, 0x91, 0x73, 0x6d, 0x66, 0x38, 0xf2, 0x3c, 0x52, 0x6e,
	0x66, 0x5a, 0x48, 0xe1, 0x4d, 0x52, 0x2c, 0xc2, 0x2d, 0x15, 0x88, 0x34, 0xfd, 0x26, 0xa0, 0x94,
	0xc8, 0xad, 0x1f, 0xf5, 0xe6, 0x50, 0x2b, 0x7c, 0x7e, 0x0b, 0x55, 0x93, 0x33, 0x83, 0xc8, 0x9c,
	0x52, 0xe2, 0x5a, 0x9b, 0x38, 0x48, 0x29, 0x98, 0xe1, 0x19, 0x4d, 0xcc, 0x31, 0x2a, 0x15, 0x5a,
	0x67, 0xb7, 0x0a, 0x95, 0x9f, 0xf6, 0xff, 0xb8, 0x3d, 0x55, 0xfe, 0xbe, 0x3d, 0x55, 0xfe, 0xbd,
	0x3d, 0x55, 0xbe, 0x6e, 0xaf, 0xfc, 0xe4, 0x9b, 0xdd, 0x4d, 0x7f, 0x11, 0xae, 0x07, 0x6b, 0x2f,
	0x4e, 0x58, 0xf4, 0xe9, 0x6a, 0xb0, 0x0a, 0x77, 0x9b, 0x70, 0xe0, 0x6d, 0xfd, 0xc1, 0xf6, 0xe6,
	0xa6, 0x22, 0x5e, 0xd9, 0xcf, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x4f, 0xea, 0x72, 0x33, 0xb2,
	0x06, 0x00, 0x00,
}
