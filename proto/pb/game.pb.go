// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: game.proto

package pb // import "github.com/master-g/gouno/proto/pb"

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Command Codes
// S -> C : even
// C -> S : odd
type GameCmd int32

const (
	GameCmd_GAME_RESERVED  GameCmd = 0
	GameCmd_ENTER_GAME_REQ GameCmd = 8193
	GameCmd_ENTER_GAME_RSP GameCmd = 8194
	GameCmd_ACTION_REQ     GameCmd = 8195
	GameCmd_ACTION_RSP     GameCmd = 8196
	GameCmd_EVENT_NTY      GameCmd = 8198
	GameCmd_GAME_OVER_NTY  GameCmd = 8200
)

var GameCmd_name = map[int32]string{
	0:    "GAME_RESERVED",
	8193: "ENTER_GAME_REQ",
	8194: "ENTER_GAME_RSP",
	8195: "ACTION_REQ",
	8196: "ACTION_RSP",
	8198: "EVENT_NTY",
	8200: "GAME_OVER_NTY",
}
var GameCmd_value = map[string]int32{
	"GAME_RESERVED":  0,
	"ENTER_GAME_REQ": 8193,
	"ENTER_GAME_RSP": 8194,
	"ACTION_REQ":     8195,
	"ACTION_RSP":     8196,
	"EVENT_NTY":      8198,
	"GAME_OVER_NTY":  8200,
}

func (x GameCmd) String() string {
	return proto.EnumName(GameCmd_name, int32(x))
}
func (GameCmd) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_game_d418705ce220b7d4, []int{0}
}

type Event int32

const (
	Event_EVENT_PLAY              Event = 0
	Event_EVENT_UNO_PLAY          Event = 1
	Event_EVENT_DRAW              Event = 2
	Event_EVENT_SKIP              Event = 3
	Event_EVENT_CHALLENGE         Event = 4
	Event_EVENT_CHALLENGE_PENALTY Event = 5
	Event_EVENT_TIMEOUT           Event = 6
	Event_EVENT_DECK_SHUFFLE      Event = 7
)

var Event_name = map[int32]string{
	0: "EVENT_PLAY",
	1: "EVENT_UNO_PLAY",
	2: "EVENT_DRAW",
	3: "EVENT_SKIP",
	4: "EVENT_CHALLENGE",
	5: "EVENT_CHALLENGE_PENALTY",
	6: "EVENT_TIMEOUT",
	7: "EVENT_DECK_SHUFFLE",
}
var Event_value = map[string]int32{
	"EVENT_PLAY":              0,
	"EVENT_UNO_PLAY":          1,
	"EVENT_DRAW":              2,
	"EVENT_SKIP":              3,
	"EVENT_CHALLENGE":         4,
	"EVENT_CHALLENGE_PENALTY": 5,
	"EVENT_TIMEOUT":           6,
	"EVENT_DECK_SHUFFLE":      7,
}

func (x Event) String() string {
	return proto.EnumName(Event_name, int32(x))
}
func (Event) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_game_d418705ce220b7d4, []int{1}
}

type CardColor int32

const (
	CardColor_COLOR_RED    CardColor = 0
	CardColor_COLOR_YELLOW CardColor = 16
	CardColor_COLOR_BLUE   CardColor = 32
	CardColor_COLOR_GREEN  CardColor = 48
)

var CardColor_name = map[int32]string{
	0:  "COLOR_RED",
	16: "COLOR_YELLOW",
	32: "COLOR_BLUE",
	48: "COLOR_GREEN",
}
var CardColor_value = map[string]int32{
	"COLOR_RED":    0,
	"COLOR_YELLOW": 16,
	"COLOR_BLUE":   32,
	"COLOR_GREEN":  48,
}

func (x CardColor) String() string {
	return proto.EnumName(CardColor_name, int32(x))
}
func (CardColor) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_game_d418705ce220b7d4, []int{2}
}

type PlayerStatus int32

const (
	PlayerStatus_STATUS_DEFAULT   PlayerStatus = 0
	PlayerStatus_STATUS_UNO       PlayerStatus = 1
	PlayerStatus_STATUS_SKIP      PlayerStatus = 2
	PlayerStatus_STATUS_CHALLENGE PlayerStatus = 4
)

var PlayerStatus_name = map[int32]string{
	0: "STATUS_DEFAULT",
	1: "STATUS_UNO",
	2: "STATUS_SKIP",
	4: "STATUS_CHALLENGE",
}
var PlayerStatus_value = map[string]int32{
	"STATUS_DEFAULT":   0,
	"STATUS_UNO":       1,
	"STATUS_SKIP":      2,
	"STATUS_CHALLENGE": 4,
}

func (x PlayerStatus) String() string {
	return proto.EnumName(PlayerStatus_name, int32(x))
}
func (PlayerStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_game_d418705ce220b7d4, []int{3}
}

type TableConfig struct {
	TurnTimeout          int32    `protobuf:"varint,1,opt,name=turn_timeout,json=turnTimeout,proto3" json:"turn_timeout,omitempty"`
	GameOverDuration     int32    `protobuf:"varint,2,opt,name=game_over_duration,json=gameOverDuration,proto3" json:"game_over_duration,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TableConfig) Reset()         { *m = TableConfig{} }
func (m *TableConfig) String() string { return proto.CompactTextString(m) }
func (*TableConfig) ProtoMessage()    {}
func (*TableConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_d418705ce220b7d4, []int{0}
}
func (m *TableConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TableConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableConfig.Merge(dst, src)
}
func (m *TableConfig) XXX_Size() int {
	return m.Size()
}
func (m *TableConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TableConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TableConfig proto.InternalMessageInfo

func (m *TableConfig) GetTurnTimeout() int32 {
	if m != nil {
		return m.TurnTimeout
	}
	return 0
}

func (m *TableConfig) GetGameOverDuration() int32 {
	if m != nil {
		return m.GameOverDuration
	}
	return 0
}

type UnoPlayer struct {
	Uid                  uint64   `protobuf:"fixed64,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Timeout              int32    `protobuf:"varint,2,opt,name=timeout,proto3" json:"timeout,omitempty"`
	Status               int32    `protobuf:"varint,3,opt,name=status,proto3" json:"status,omitempty"`
	Cards                []byte   `protobuf:"bytes,4,opt,name=cards,proto3" json:"cards,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnoPlayer) Reset()         { *m = UnoPlayer{} }
func (m *UnoPlayer) String() string { return proto.CompactTextString(m) }
func (*UnoPlayer) ProtoMessage()    {}
func (*UnoPlayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_d418705ce220b7d4, []int{1}
}
func (m *UnoPlayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnoPlayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnoPlayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UnoPlayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnoPlayer.Merge(dst, src)
}
func (m *UnoPlayer) XXX_Size() int {
	return m.Size()
}
func (m *UnoPlayer) XXX_DiscardUnknown() {
	xxx_messageInfo_UnoPlayer.DiscardUnknown(m)
}

var xxx_messageInfo_UnoPlayer proto.InternalMessageInfo

func (m *UnoPlayer) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UnoPlayer) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *UnoPlayer) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *UnoPlayer) GetCards() []byte {
	if m != nil {
		return m.Cards
	}
	return nil
}

type S2CTableState struct {
	Tid                  uint64       `protobuf:"fixed64,1,opt,name=tid,proto3" json:"tid,omitempty"`
	Playing              bool         `protobuf:"varint,2,opt,name=playing,proto3" json:"playing,omitempty"`
	Clockwise            bool         `protobuf:"varint,3,opt,name=clockwise,proto3" json:"clockwise,omitempty"`
	DealerUid            uint64       `protobuf:"fixed64,4,opt,name=dealer_uid,json=dealerUid,proto3" json:"dealer_uid,omitempty"`
	LastPlayer           uint64       `protobuf:"fixed64,5,opt,name=last_player,json=lastPlayer,proto3" json:"last_player,omitempty"`
	CurrentPlayer        uint64       `protobuf:"fixed64,6,opt,name=current_player,json=currentPlayer,proto3" json:"current_player,omitempty"`
	CardsLeft            int32        `protobuf:"varint,7,opt,name=cards_left,json=cardsLeft,proto3" json:"cards_left,omitempty"`
	TableConfig          *TableConfig `protobuf:"bytes,8,opt,name=table_config,json=tableConfig" json:"table_config,omitempty"`
	CardsPlayed          []byte       `protobuf:"bytes,9,opt,name=cards_played,json=cardsPlayed,proto3" json:"cards_played,omitempty"`
	Players              []*UnoPlayer `protobuf:"bytes,10,rep,name=players" json:"players,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *S2CTableState) Reset()         { *m = S2CTableState{} }
func (m *S2CTableState) String() string { return proto.CompactTextString(m) }
func (*S2CTableState) ProtoMessage()    {}
func (*S2CTableState) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_d418705ce220b7d4, []int{2}
}
func (m *S2CTableState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CTableState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CTableState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2CTableState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CTableState.Merge(dst, src)
}
func (m *S2CTableState) XXX_Size() int {
	return m.Size()
}
func (m *S2CTableState) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CTableState.DiscardUnknown(m)
}

var xxx_messageInfo_S2CTableState proto.InternalMessageInfo

func (m *S2CTableState) GetTid() uint64 {
	if m != nil {
		return m.Tid
	}
	return 0
}

func (m *S2CTableState) GetPlaying() bool {
	if m != nil {
		return m.Playing
	}
	return false
}

func (m *S2CTableState) GetClockwise() bool {
	if m != nil {
		return m.Clockwise
	}
	return false
}

func (m *S2CTableState) GetDealerUid() uint64 {
	if m != nil {
		return m.DealerUid
	}
	return 0
}

func (m *S2CTableState) GetLastPlayer() uint64 {
	if m != nil {
		return m.LastPlayer
	}
	return 0
}

func (m *S2CTableState) GetCurrentPlayer() uint64 {
	if m != nil {
		return m.CurrentPlayer
	}
	return 0
}

func (m *S2CTableState) GetCardsLeft() int32 {
	if m != nil {
		return m.CardsLeft
	}
	return 0
}

func (m *S2CTableState) GetTableConfig() *TableConfig {
	if m != nil {
		return m.TableConfig
	}
	return nil
}

func (m *S2CTableState) GetCardsPlayed() []byte {
	if m != nil {
		return m.CardsPlayed
	}
	return nil
}

func (m *S2CTableState) GetPlayers() []*UnoPlayer {
	if m != nil {
		return m.Players
	}
	return nil
}

type C2SAction struct {
	Event                int32    `protobuf:"varint,1,opt,name=event,proto3" json:"event,omitempty"`
	Card                 []byte   `protobuf:"bytes,2,opt,name=card,proto3" json:"card,omitempty"`
	WildColor            int32    `protobuf:"varint,3,opt,name=wild_color,json=wildColor,proto3" json:"wild_color,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2SAction) Reset()         { *m = C2SAction{} }
func (m *C2SAction) String() string { return proto.CompactTextString(m) }
func (*C2SAction) ProtoMessage()    {}
func (*C2SAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_d418705ce220b7d4, []int{3}
}
func (m *C2SAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *C2SAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SAction.Merge(dst, src)
}
func (m *C2SAction) XXX_Size() int {
	return m.Size()
}
func (m *C2SAction) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SAction.DiscardUnknown(m)
}

var xxx_messageInfo_C2SAction proto.InternalMessageInfo

func (m *C2SAction) GetEvent() int32 {
	if m != nil {
		return m.Event
	}
	return 0
}

func (m *C2SAction) GetCard() []byte {
	if m != nil {
		return m.Card
	}
	return nil
}

func (m *C2SAction) GetWildColor() int32 {
	if m != nil {
		return m.WildColor
	}
	return 0
}

type S2CEventNty struct {
	Uid                  uint64   `protobuf:"fixed64,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Event                int32    `protobuf:"varint,2,opt,name=event,proto3" json:"event,omitempty"`
	WildColor            int32    `protobuf:"varint,3,opt,name=wild_color,json=wildColor,proto3" json:"wild_color,omitempty"`
	Card                 []byte   `protobuf:"bytes,4,opt,name=card,proto3" json:"card,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CEventNty) Reset()         { *m = S2CEventNty{} }
func (m *S2CEventNty) String() string { return proto.CompactTextString(m) }
func (*S2CEventNty) ProtoMessage()    {}
func (*S2CEventNty) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_d418705ce220b7d4, []int{4}
}
func (m *S2CEventNty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CEventNty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CEventNty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2CEventNty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CEventNty.Merge(dst, src)
}
func (m *S2CEventNty) XXX_Size() int {
	return m.Size()
}
func (m *S2CEventNty) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CEventNty.DiscardUnknown(m)
}

var xxx_messageInfo_S2CEventNty proto.InternalMessageInfo

func (m *S2CEventNty) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *S2CEventNty) GetEvent() int32 {
	if m != nil {
		return m.Event
	}
	return 0
}

func (m *S2CEventNty) GetWildColor() int32 {
	if m != nil {
		return m.WildColor
	}
	return 0
}

func (m *S2CEventNty) GetCard() []byte {
	if m != nil {
		return m.Card
	}
	return nil
}

type S2CGameOverNty struct {
	Ranks                []uint64 `protobuf:"fixed64,1,rep,packed,name=ranks" json:"ranks,omitempty"`
	Scores               []int32  `protobuf:"varint,2,rep,packed,name=scores" json:"scores,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CGameOverNty) Reset()         { *m = S2CGameOverNty{} }
func (m *S2CGameOverNty) String() string { return proto.CompactTextString(m) }
func (*S2CGameOverNty) ProtoMessage()    {}
func (*S2CGameOverNty) Descriptor() ([]byte, []int) {
	return fileDescriptor_game_d418705ce220b7d4, []int{5}
}
func (m *S2CGameOverNty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CGameOverNty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CGameOverNty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2CGameOverNty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CGameOverNty.Merge(dst, src)
}
func (m *S2CGameOverNty) XXX_Size() int {
	return m.Size()
}
func (m *S2CGameOverNty) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CGameOverNty.DiscardUnknown(m)
}

var xxx_messageInfo_S2CGameOverNty proto.InternalMessageInfo

func (m *S2CGameOverNty) GetRanks() []uint64 {
	if m != nil {
		return m.Ranks
	}
	return nil
}

func (m *S2CGameOverNty) GetScores() []int32 {
	if m != nil {
		return m.Scores
	}
	return nil
}

func init() {
	proto.RegisterType((*TableConfig)(nil), "proto.game.TableConfig")
	proto.RegisterType((*UnoPlayer)(nil), "proto.game.UnoPlayer")
	proto.RegisterType((*S2CTableState)(nil), "proto.game.S2CTableState")
	proto.RegisterType((*C2SAction)(nil), "proto.game.C2SAction")
	proto.RegisterType((*S2CEventNty)(nil), "proto.game.S2CEventNty")
	proto.RegisterType((*S2CGameOverNty)(nil), "proto.game.S2CGameOverNty")
	proto.RegisterEnum("proto.game.GameCmd", GameCmd_name, GameCmd_value)
	proto.RegisterEnum("proto.game.Event", Event_name, Event_value)
	proto.RegisterEnum("proto.game.CardColor", CardColor_name, CardColor_value)
	proto.RegisterEnum("proto.game.PlayerStatus", PlayerStatus_name, PlayerStatus_value)
}
func (m *TableConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TurnTimeout != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.TurnTimeout))
	}
	if m.GameOverDuration != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.GameOverDuration))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UnoPlayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnoPlayer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Uid))
		i += 8
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Timeout))
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Status))
	}
	if len(m.Cards) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Cards)))
		i += copy(dAtA[i:], m.Cards)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *S2CTableState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CTableState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tid != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Tid))
		i += 8
	}
	if m.Playing {
		dAtA[i] = 0x10
		i++
		if m.Playing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Clockwise {
		dAtA[i] = 0x18
		i++
		if m.Clockwise {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DealerUid != 0 {
		dAtA[i] = 0x21
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.DealerUid))
		i += 8
	}
	if m.LastPlayer != 0 {
		dAtA[i] = 0x29
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.LastPlayer))
		i += 8
	}
	if m.CurrentPlayer != 0 {
		dAtA[i] = 0x31
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.CurrentPlayer))
		i += 8
	}
	if m.CardsLeft != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.CardsLeft))
	}
	if m.TableConfig != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.TableConfig.Size()))
		n1, err := m.TableConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.CardsPlayed) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.CardsPlayed)))
		i += copy(dAtA[i:], m.CardsPlayed)
	}
	if len(m.Players) > 0 {
		for _, msg := range m.Players {
			dAtA[i] = 0x52
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *C2SAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Event != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Event))
	}
	if len(m.Card) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Card)))
		i += copy(dAtA[i:], m.Card)
	}
	if m.WildColor != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.WildColor))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *S2CEventNty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CEventNty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Uid))
		i += 8
	}
	if m.Event != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Event))
	}
	if m.WildColor != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.WildColor))
	}
	if len(m.Card) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Card)))
		i += copy(dAtA[i:], m.Card)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *S2CGameOverNty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CGameOverNty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ranks) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Ranks)*8))
		for _, num := range m.Ranks {
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(num))
			i += 8
		}
	}
	if len(m.Scores) > 0 {
		dAtA3 := make([]byte, len(m.Scores)*10)
		var j2 int
		for _, num1 := range m.Scores {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintGame(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TableConfig) Size() (n int) {
	var l int
	_ = l
	if m.TurnTimeout != 0 {
		n += 1 + sovGame(uint64(m.TurnTimeout))
	}
	if m.GameOverDuration != 0 {
		n += 1 + sovGame(uint64(m.GameOverDuration))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnoPlayer) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 9
	}
	if m.Timeout != 0 {
		n += 1 + sovGame(uint64(m.Timeout))
	}
	if m.Status != 0 {
		n += 1 + sovGame(uint64(m.Status))
	}
	l = len(m.Cards)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CTableState) Size() (n int) {
	var l int
	_ = l
	if m.Tid != 0 {
		n += 9
	}
	if m.Playing {
		n += 2
	}
	if m.Clockwise {
		n += 2
	}
	if m.DealerUid != 0 {
		n += 9
	}
	if m.LastPlayer != 0 {
		n += 9
	}
	if m.CurrentPlayer != 0 {
		n += 9
	}
	if m.CardsLeft != 0 {
		n += 1 + sovGame(uint64(m.CardsLeft))
	}
	if m.TableConfig != nil {
		l = m.TableConfig.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.CardsPlayed)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *C2SAction) Size() (n int) {
	var l int
	_ = l
	if m.Event != 0 {
		n += 1 + sovGame(uint64(m.Event))
	}
	l = len(m.Card)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.WildColor != 0 {
		n += 1 + sovGame(uint64(m.WildColor))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CEventNty) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 9
	}
	if m.Event != 0 {
		n += 1 + sovGame(uint64(m.Event))
	}
	if m.WildColor != 0 {
		n += 1 + sovGame(uint64(m.WildColor))
	}
	l = len(m.Card)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CGameOverNty) Size() (n int) {
	var l int
	_ = l
	if len(m.Ranks) > 0 {
		n += 1 + sovGame(uint64(len(m.Ranks)*8)) + len(m.Ranks)*8
	}
	if len(m.Scores) > 0 {
		l = 0
		for _, e := range m.Scores {
			l += sovGame(uint64(e))
		}
		n += 1 + sovGame(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovGame(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGame(x uint64) (n int) {
	return sovGame(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TableConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TurnTimeout", wireType)
			}
			m.TurnTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TurnTimeout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameOverDuration", wireType)
			}
			m.GameOverDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameOverDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnoPlayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnoPlayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnoPlayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards[:0], dAtA[iNdEx:postIndex]...)
			if m.Cards == nil {
				m.Cards = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CTableState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CTableState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CTableState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			m.Tid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Tid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Playing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Playing = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clockwise", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Clockwise = bool(v != 0)
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DealerUid", wireType)
			}
			m.DealerUid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.DealerUid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastPlayer", wireType)
			}
			m.LastPlayer = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.LastPlayer = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentPlayer", wireType)
			}
			m.CurrentPlayer = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentPlayer = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardsLeft", wireType)
			}
			m.CardsLeft = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardsLeft |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableConfig == nil {
				m.TableConfig = &TableConfig{}
			}
			if err := m.TableConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardsPlayed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CardsPlayed = append(m.CardsPlayed[:0], dAtA[iNdEx:postIndex]...)
			if m.CardsPlayed == nil {
				m.CardsPlayed = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &UnoPlayer{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			m.Event = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Event |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Card = append(m.Card[:0], dAtA[iNdEx:postIndex]...)
			if m.Card == nil {
				m.Card = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WildColor", wireType)
			}
			m.WildColor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WildColor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CEventNty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CEventNty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CEventNty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			m.Event = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Event |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WildColor", wireType)
			}
			m.WildColor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WildColor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Card = append(m.Card[:0], dAtA[iNdEx:postIndex]...)
			if m.Card == nil {
				m.Card = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CGameOverNty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CGameOverNty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CGameOverNty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.Ranks = append(m.Ranks, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGame
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if len(m.Ranks) == 0 {
					m.Ranks = make([]uint64, 0, packedLen/8)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.Ranks = append(m.Ranks, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranks", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Scores = append(m.Scores, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGame
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGame
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Scores = append(m.Scores, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Scores", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGame(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGame
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGame
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGame
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGame
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGame
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGame(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGame = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGame   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("game.proto", fileDescriptor_game_d418705ce220b7d4) }

var fileDescriptor_game_d418705ce220b7d4 = []byte{
	// 815 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x94, 0xdb, 0x6e, 0xe3, 0x44,
	0x18, 0xc7, 0xeb, 0x9c, 0x5a, 0x7f, 0x4e, 0xd3, 0x61, 0xb6, 0xec, 0x5a, 0x82, 0x2d, 0x21, 0x12,
	0x52, 0x54, 0x41, 0xb2, 0x0a, 0x77, 0x5c, 0xa0, 0x78, 0xdd, 0x69, 0xb7, 0x5a, 0xd7, 0x0e, 0x3e,
	0x74, 0x15, 0x2e, 0xb0, 0x5c, 0x7b, 0x9a, 0xb5, 0xd6, 0xb1, 0x2b, 0x7b, 0xd2, 0x55, 0x2f, 0x39,
	0x08, 0x71, 0xc1, 0x83, 0xf0, 0x28, 0x5c, 0xf2, 0x08, 0xa8, 0x2f, 0xc0, 0x2b, 0xa0, 0x99, 0x71,
	0x9a, 0x6c, 0x85, 0xb8, 0xaa, 0xff, 0xbf, 0xf9, 0xe6, 0xfb, 0xcf, 0x77, 0x68, 0x00, 0x16, 0xd1,
	0x92, 0x8e, 0x6e, 0xca, 0x82, 0x15, 0x18, 0xc4, 0x9f, 0x11, 0x27, 0x83, 0x1f, 0x40, 0xf3, 0xa3,
	0xab, 0x8c, 0x9a, 0x45, 0x7e, 0x9d, 0x2e, 0xf0, 0xe7, 0xd0, 0x65, 0xab, 0x32, 0x0f, 0x59, 0xba,
	0xa4, 0xc5, 0x8a, 0xe9, 0x4a, 0x5f, 0x19, 0xb6, 0x5d, 0x8d, 0x33, 0x5f, 0x22, 0xfc, 0x25, 0x60,
	0x7e, 0x33, 0x2c, 0x6e, 0x69, 0x19, 0x26, 0xab, 0x32, 0x62, 0x69, 0x91, 0xeb, 0x0d, 0x11, 0x88,
	0xf8, 0x89, 0x73, 0x4b, 0xcb, 0x93, 0x9a, 0x0f, 0x28, 0xa8, 0x41, 0x5e, 0xcc, 0xb2, 0xe8, 0x8e,
	0x96, 0x18, 0x41, 0x73, 0x95, 0x26, 0x22, 0x69, 0xc7, 0xe5, 0x9f, 0x58, 0x87, 0xdd, 0xb5, 0x95,
	0xcc, 0xb0, 0x96, 0xf8, 0x29, 0x74, 0x2a, 0x16, 0xb1, 0x55, 0xa5, 0x37, 0xc5, 0x41, 0xad, 0xf0,
	0x21, 0xb4, 0xe3, 0xa8, 0x4c, 0x2a, 0xbd, 0xd5, 0x57, 0x86, 0x5d, 0x57, 0x8a, 0xc1, 0x3f, 0x0d,
	0xd8, 0xf7, 0x26, 0xa6, 0x28, 0xc5, 0x63, 0x11, 0xa3, 0xdc, 0x8b, 0x6d, 0xbc, 0x98, 0xf4, 0xba,
	0xc9, 0xa2, 0xbb, 0x34, 0x5f, 0x08, 0xaf, 0x3d, 0x77, 0x2d, 0xf1, 0xa7, 0xa0, 0xc6, 0x59, 0x11,
	0xbf, 0x7b, 0x9f, 0x56, 0x54, 0xd8, 0xed, 0xb9, 0x1b, 0x80, 0x9f, 0x03, 0x24, 0x34, 0xca, 0x68,
	0x19, 0xf2, 0xc7, 0xb7, 0x44, 0x42, 0x55, 0x92, 0x20, 0x4d, 0xf0, 0x67, 0xa0, 0x65, 0x51, 0xc5,
	0xc2, 0x1b, 0x51, 0xa3, 0xde, 0x16, 0xe7, 0xc0, 0x51, 0x5d, 0xf5, 0x17, 0xd0, 0x8b, 0x57, 0x65,
	0x49, 0xf3, 0x87, 0x98, 0x8e, 0x88, 0xd9, 0xaf, 0x69, 0x1d, 0xf6, 0x1c, 0x40, 0xd4, 0x12, 0x66,
	0xf4, 0x9a, 0xe9, 0xbb, 0xa2, 0x68, 0x55, 0x10, 0x8b, 0x5e, 0x33, 0xfc, 0x0d, 0x74, 0x19, 0xaf,
	0x2e, 0x8c, 0xc5, 0xa4, 0xf4, 0xbd, 0xbe, 0x32, 0xd4, 0x26, 0xcf, 0x46, 0x9b, 0x59, 0x8e, 0xb6,
	0x06, 0xe9, 0x6a, 0xec, 0xc3, 0xa9, 0xca, 0xd4, 0xc2, 0x3f, 0xd1, 0x55, 0xd1, 0x3a, 0x4d, 0x30,
	0xe1, 0x9e, 0xe0, 0xb1, 0x6c, 0x0e, 0x2d, 0x2b, 0x1d, 0xfa, 0xcd, 0xa1, 0x36, 0xf9, 0x78, 0x3b,
	0xf3, 0xc3, 0x08, 0xdd, 0x75, 0xd4, 0xc0, 0x07, 0xd5, 0x9c, 0x78, 0x46, 0xcc, 0xa7, 0xcc, 0x87,
	0x42, 0x6f, 0x69, 0xbe, 0xde, 0x17, 0x29, 0x30, 0x86, 0x16, 0xb7, 0x10, 0xdd, 0xee, 0xba, 0xe2,
	0x9b, 0x57, 0xf9, 0x3e, 0xcd, 0x92, 0x30, 0x2e, 0xb2, 0xa2, 0xac, 0x47, 0xab, 0x72, 0x62, 0x72,
	0x30, 0x78, 0x0b, 0x9a, 0x37, 0x31, 0x09, 0xbf, 0x6e, 0xb3, 0xbb, 0xff, 0x58, 0x98, 0x07, 0xa7,
	0xc6, 0xb6, 0xd3, 0xff, 0x67, 0x7d, 0x78, 0x48, 0x6b, 0xf3, 0x90, 0xc1, 0xb7, 0xd0, 0xf3, 0x26,
	0xe6, 0x59, 0xbd, 0xaf, 0xdc, 0xec, 0x10, 0xda, 0x65, 0x94, 0xbf, 0xab, 0x74, 0xa5, 0xdf, 0x1c,
	0x76, 0x5c, 0x29, 0xc4, 0x1e, 0xc6, 0x45, 0x49, 0x2b, 0xbd, 0xd1, 0x6f, 0x8a, 0x3d, 0x14, 0xea,
	0xf8, 0x77, 0x05, 0x76, 0xf9, 0x6d, 0x73, 0x99, 0xe0, 0x8f, 0x60, 0xff, 0xcc, 0xb8, 0x20, 0xa1,
	0x4b, 0x3c, 0xe2, 0x5e, 0x92, 0x13, 0xb4, 0x83, 0x9f, 0x40, 0x8f, 0xd8, 0x3e, 0x71, 0xc3, 0xfa,
	0xe0, 0x3b, 0xf4, 0xe3, 0xf4, 0x31, 0xf4, 0x66, 0xe8, 0xa7, 0x29, 0x3e, 0x00, 0x30, 0x4c, 0xff,
	0xdc, 0xb1, 0x45, 0xd4, 0xcf, 0x1f, 0x00, 0x6f, 0x86, 0x7e, 0x99, 0xe2, 0x1e, 0xa8, 0xe4, 0x92,
	0xd8, 0x7e, 0x68, 0xfb, 0x73, 0xf4, 0xeb, 0x14, 0xe3, 0xda, 0xce, 0xb9, 0x24, 0xae, 0x60, 0xbf,
	0x4d, 0x8f, 0xff, 0x50, 0xa0, 0x2d, 0xda, 0x86, 0x7b, 0x00, 0x32, 0x7a, 0x66, 0x19, 0x73, 0xb4,
	0x83, 0x31, 0xf4, 0xa4, 0x0e, 0x6c, 0x47, 0x32, 0x65, 0x13, 0x73, 0xe2, 0x1a, 0x6f, 0x50, 0x63,
	0xa3, 0xbd, 0xd7, 0xe7, 0x33, 0xd4, 0xc4, 0x4f, 0xe0, 0x40, 0x6a, 0xf3, 0x95, 0x61, 0x59, 0xc4,
	0x3e, 0x23, 0xa8, 0x85, 0x3f, 0x81, 0x67, 0x8f, 0x60, 0x38, 0x23, 0xb6, 0x61, 0xf9, 0x73, 0xd4,
	0xe6, 0x2d, 0x90, 0x87, 0xfe, 0xf9, 0x05, 0x71, 0x02, 0x1f, 0x75, 0xf0, 0x53, 0xc0, 0xb5, 0x09,
	0x31, 0x5f, 0x87, 0xde, 0xab, 0xe0, 0xf4, 0xd4, 0x22, 0x68, 0xf7, 0xf8, 0x02, 0x54, 0x33, 0x2a,
	0xeb, 0xd1, 0xec, 0x83, 0x6a, 0x3a, 0x96, 0xe3, 0x86, 0xae, 0x68, 0x1b, 0x82, 0xae, 0x94, 0x73,
	0x62, 0x59, 0xce, 0x1b, 0x84, 0xf8, 0xd3, 0x24, 0x79, 0x69, 0x05, 0x04, 0xf5, 0xf1, 0x01, 0x68,
	0x52, 0x9f, 0xb9, 0x84, 0xd8, 0xe8, 0xc5, 0xf1, 0x1c, 0xba, 0x72, 0x37, 0x3d, 0xf9, 0x03, 0x81,
	0xa1, 0xe7, 0xf9, 0x86, 0x1f, 0x78, 0xe1, 0x09, 0x39, 0x35, 0x02, 0xcb, 0x47, 0x3b, 0x3c, 0x49,
	0xcd, 0x02, 0xdb, 0x41, 0x0a, 0x4f, 0x52, 0x6b, 0x51, 0x70, 0x03, 0x1f, 0x02, 0xaa, 0xc1, 0x56,
	0xc5, 0x2f, 0x5f, 0xfc, 0x79, 0x7f, 0xa4, 0xfc, 0x75, 0x7f, 0xa4, 0xfc, 0x7d, 0x7f, 0xa4, 0x7c,
	0x3f, 0x58, 0xa4, 0xec, 0xed, 0xea, 0x6a, 0x14, 0x17, 0xcb, 0xf1, 0x32, 0xaa, 0x18, 0x2d, 0xbf,
	0x5a, 0x8c, 0x17, 0xc5, 0x2a, 0x2f, 0xc6, 0xe2, 0x5f, 0x65, 0x7c, 0x73, 0x75, 0xd5, 0x11, 0x5f,
	0x5f, 0xff, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x6d, 0xd5, 0x98, 0x01, 0x6f, 0x05, 0x00, 0x00,
}
